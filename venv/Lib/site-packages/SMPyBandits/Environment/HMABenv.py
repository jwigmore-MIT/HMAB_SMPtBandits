import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm, uniform
from random import randint
from .MAB import MAB
from ..Arms import UniformArm

try:
    from .pykov import Chain
except ImportError as e:
    try:
        from pykov import Chain
    except ImportError:
        print("Warning: 'pykov' module seems to not be available. But it is shipped with SMPyBandits. Weird.")
        print("Dou you want to try to install it from https://github.com/riccardoscalco/Pykov ?")
        print("Warning: the 'MarkovianMAB' class will not work...")

# Local imports
try:
    from .plotsettings import signature, wraptext, wraplatex, palette, makemarkers, legend, show_and_save
except ImportError:
    from plotsettings import signature, wraptext, wraplatex, palette, makemarkers, legend, show_and_save

class HMABenv(object):

    def __init__(self, envConfig):
        """

        :param envConfig: <dict> contains parameters to set up the MAB environment
                "isHMAB": <bool> whether or not the environment is for the HMAB setting
                "bandConfig": <dict> contains parameters (both statistical ("bandParams") and non-statistical (e.g. nbBins) to set up each Band object in the environment
                "compareMab" <bool> whether or not to create an equivalent MAB environment
        """
        print("\n\nCreating a new MAB problem ...")  # DEBUG
        self.isChangingAtEachRepetition = False  #: Flag to know if the problem is changing at each repetition or not.
        self.isDynamic = False  #: Flag to know if the problem is static or not.
        self.isMarkovian = False  #: Flag to know if the problem is Markovian or not.
        self.arms = []  #: List of arms
        self._sparsity = None
        self.isHMAB = True


        if isinstance(envConfig, dict):
            print("  Reading arms of this MAB problem from a dictionnary 'envConfig' = {} ...".format(
                envConfig))  # DEBUG
            self.nbBands = envConfig["nbBands"]     # Number of Bands
            self.nbBins = envConfig["nbBins"]     # Number of bins per Band
            self.nbArms = self.nbBands*self.nbBins     # Total number of arms between all Bands
            self.Bands = list()                 # List of Z_i's - i.e. band distributions
            for n in range(self.nbBands):

                self.Bands.append(self.Band(envConfig,n)) # Creates a new Band instance and stores it in Z (list)
                self.arms.extend(self.Z[-1].arms) # Copies the arms from the newly created Band instance for the Environment level
        self.means=np.array([arm.mean for arm in self.arms]) # mean of all arms (i.e. lam_ij forall ij)
        self.maxArm = np.max(self.means)  #: Max mean of arms
        self.minArm = np.min(self.means)  #: Min mean of arms
        self.BestBandBinValue = -np.inf
        self.BestBandBin = None
        self.sparsity()
        self.armsSort = None

        for B in range(self.nbBands):
            Band = self.Z[B]
            if Band.lam[Band.bestArm] >= self.BestBandBinValue:
                self.BestBandBin = (B,Band.bestArm)
                self.BestBandBinValue = Band.lam[Band.bestArm]
        if envConfig["verbose"]:
            print("*"*20)
            print("STATS FOR EACH BAND")
            for B in range(self.nbBands):
                Band = self.Z[B]
                print(f"BAND {B}/{self.nbBands-1}")
                print(f"({B})|Distribution = {Band.bandDistribution} with parameters (loc = {Band.loc},scale = {Band.scale})")
                print(f"({B})|Number of Arms (Bins) = {Band.nbBins}")
                print(f"({B})|Arm Distributions = [{Band.arms}]")
                print(f"({B})|Best Arm = [{Band.bestArm}] with expected reward  = {Band.lam[Band.bestArm]:0.4f}")

        self.bestArm = self.getArm(self.BestBandBin[0],self.BestBandBin[1])
        if envConfig["verbose"]:
            print("*" * 20)
            print("OVERALL STATS")
            print(f"Total # of total 'Arms' (Bins) = {self.nbArms}")
            print(f"Best (Band,Bin) [Arm] = {self.BestBandBin} [{self.bestArm}]  w/ expected reward = {self.BestBandBinValue}")
            print("*" * 20)
            print("DONE INITIALIZING THE ENVIRONMENT")
            print("*" * 20)
            print()

    def getArmsSorted(self):
        self.bestArms = np.flip(np.argsort(self.means))
        self.bestArmValues = self.means[self.bestArms]

    def printEnvInfo(self):
        print("*" * 20)
        print("### STATS FOR EACH BAND")
        for B in range(self.nbBands):
            Band = self.Z[B]
            print(f"#### BAND {B}/{self.nbBands - 1}")
            print(
                f"({B})|Distribution = {Band.bandDistribution} with parameters (loc = {Band.loc},scale = {Band.scale})")
            print(f"({B})|Number of Arms (Bins) = {Band.nbBins}")
            print(f"({B})|Arm Distributions = [{Band.arms}]")
            print(f"({B})|Best Arm = [{Band.bestArm}] with expected reward  = {Band.lam[Band.bestArm]:0.4f}")
        print("*" * 20)
        print("### OVERALL STATS")
        print(f"Total # of total 'Arms' (Bins) = {self.nbArms}")
        self.getArmsSorted()

        print(
            f"1st Best (Band,Bin) [Arm] = {self.getBB(self.bestArms[0])} [{self.bestArms[0]}]  w/ expected reward = {self.bestArmValues[0]}")
        print(
            f"2nd Best (Band,Bin) [Arm] = {self.getBB(self.bestArms[1])} [{self.bestArms[1]}]  w/ expected reward = {self.bestArmValues[1]}")
        print(f"Gap = {self.bestArmValues[0] - self.bestArmValues[1]}")
        print("*" * 20)
        print("*" * 20)
        print()


    class Band:
        #The Band should just be another MAB object (Maybe)
        
        def __init__(self, envConfig, n):
            bandConfig = envConfig["bandConfig"]
            bandParams = bandConfig["bandParams"]
            binConfig = bandConfig["binConfig"]
            self.i = n   # Band index
            self.nbBins = bandConfig["nbBins"]
            self.bandDistribution = bandConfig["bandDistribution"]  # Distribution of Z_i i.e. mean reward distribution
            self.binDistribution = bandConfig["binDistribution"]
            self.empDistribution = {}
            if self.bandDistribution == "Gaussian": ## CHANGE ALL BANDPARAMS TO BE DICT BASED
                self.Mu = bandParams["mu"][n]  # Band mean
                self.Std = bandParams["std"][n]   # Band standard deviation
                self.Z_i = norm(loc = self.Mu, scale = self.Std) # Distribution of the Band (scipy rv object)
                self.arms = list()
                self.lam = self.Z_i.rvs(self.nbBins) # Create bin means by sampling Z_i
                self.bin_std = binConfig["std"] # set bin standard deviation
                self.loc = self.Mu
                self.scale = self.Std
                for l in self.lam:
                    self.arms.append(self.binDistribution(l, self.bin_std))  #Appending arm e.g. Gaussian(lam_ij, sigma_ij)
                self.empDistribution["loc"] = np.mean(self.lam)
                self.empDistribution["scale"] = np.std(self.lam)
                self.Z_i_emp = norm(loc = self.empDistribution["loc"], scale =self.empDistribution["scale"] )
            elif self.bandDistribution == "Uniform":
                self.min= bandParams["min"][n]  #Band lower bound (i.e. lower bound of expected bin rewards within the band)
                self.loc = self.min
                self.scale = bandParams["scale"][n] #Scale parameter for the band i.e. width of distribution
                self.max = self.min + self.scale
                self.Z_i = uniform(loc = self.min, scale = self.scale) #Distribution of Band
                self.arms = list()
                self.lam = self.Z_i.rvs(self.nbBins) # Sample of means
                for l in self.lam: # Now we need to create the bin distributions
                    if issubclass(self.binDistribution, UniformArm):
                        mini = l - binConfig["scale"]/2
                        maxi = l + binConfig["scale"]/2
                        self.arms.append(self.binDistribution(mini, maxi))



            # Now we need to create M arms with arm_type Gaussian and means sampled from Z_i
            self.bestArm = np.argmax(self.lam)  # Arm with the highest expected reward within the Band
        def sample_bin(self, method = "uniform"):
            if method == 'uniform':
                bin_index = randint(0,self.nbBins)
                reward = arms
            else:
                pass
            return reward, bin_index

        def printBandDist(self):
            self.bandDistribution


    def draw(self, choice, t=1):
        """ Return a random sample from the armId-th arm, at time t. Usually t is not used."""
        if isinstance(choice, np.int64) or isinstance(choice, int):
            choice = self.getBB(choice)
        Band = choice[0]
        Bin = choice[1]
        reward = self.Z[Band].arms[Bin].draw(t)
        #print(f"Drawing from (Band, Bin): {choice} which has a rewards ~ N({self.Z[Band].arms[Bin].mean:0.3f},{self.Z[Band].arms[Bin].sigma**2})")
        #print(f"Reward drawn: {reward}")
        return reward

    def get_maxArm(self, horizon=None):
        """Return the vector of max mean of the arms.

        - It is a vector of length horizon.
        """
        return np.full(horizon, self.maxArm)
            

    def sparsity(self):
        """ Estimate the sparsity of the problem, i.e., the number of arms with positive means."""
        if self._sparsity is not None:
            return self._sparsity
        else:
            return np.count_nonzero(self.means > 0)

    def str_sparsity(self):
        """ Empty string if ``sparsity = nbArms``, or a small string ', $s={}$' if the sparsity is strictly less than the number of arm."""
        s, K = self.sparsity(), self.nbArms
        assert 0 <= s <= K, "Error: sparsity s = {} has to be 0 <= s <= K = {}...".format(s, K)
        # WARNING
        # disable this feature when not working on sparse simulations
        # return ""
        # or bring back this feature when working on sparse simulations
        return "" if s == K else ", $s={}$".format(s)

    def lowerbound(self):
        r""" Compute the constant :math:`C(\mu)`, for the [Lai & Robbins] lower-bound for this MAB problem (complexity), using functions from ``kullback.py`` or ``kullback.so`` (see :mod:`Arms.kullback`). """
        return sum(a.oneLR(self.maxArm, a.mean) for a in self.arms if a.mean != self.maxArm)
            
    def reprarms(self, nbPlayers=None, openTag='', endTag='^*', latex=True):
        """ Return a str representation of the list of the arms (like `repr(self.arms)` but better)

        - If nbPlayers > 0, it surrounds the representation of the best arms by openTag, endTag (for plot titles, in a multi-player setting).

        - Example: openTag = '', endTag = '^*' for LaTeX tags to put a star exponent.
        - Example: openTag = '<red>', endTag = '</red>' for HTML-like tags.
        - Example: openTag = r'\textcolor{red}{', endTag = '}' for LaTeX tags.
        """
        if nbPlayers is None:
            text = repr(self.arms)
        else:
            assert nbPlayers >= 0, "Error, the 'nbPlayers' argument for reprarms method of a MAB object has to be a non-negative integer."  # DEBUG
            append_to_repr = ""

            means = self.means
            bestmean = np.max(means)
            bestArms = np.argsort(means)[-min(nbPlayers, self.nbArms):]
            repr_arms = [repr(arm) for arm in self.arms]

            # WARNING improve display for Gaussian arms that all have same variance
            if all("Gaussian" in str(type(arm)) for arm in self.arms) and len({arm.sigma for arm in self.arms}) == 1:
                sigma = self.arms[0].sigma
                repr_arms = [s.replace(', {:.3g}'.format(sigma), '') for s in repr_arms]
                append_to_repr = r", \sigma^2={:.3g}".format(sigma) if latex else ", sigma2={:.3g}".format(sigma)

            if nbPlayers == 0: bestArms = []
            text = '[{}]'.format(', '.join(
                openTag + repr_arms[armId] + endTag
                if (nbPlayers > 0 and (armId in bestArms or np.isclose(arm.mean, bestmean)))
                else repr_arms[armId]
                for armId, arm in enumerate(self.arms))
            )
            text += append_to_repr
        return wraplatex('$' + text + '$') if latex else wraptext(text)

    def createMAB(self):
        envConfig = self.arms
        return MAB(envConfig)

    def getArm(self, Band, Bin):
        return np.ravel_multi_index((Band, Bin), (self.nbBands, self.nbBins))

    def getBB(self, arm):
        return np.unravel_index(arm, (self.nbBands, self.nbBins))