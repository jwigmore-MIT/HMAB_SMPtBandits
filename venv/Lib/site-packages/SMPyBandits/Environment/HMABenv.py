import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm, uniform
from random import randint
from .MAB import MAB
from ..Arms import UniformArm, UnboundedGaussian
from ..Distribution import Normal

try:
    from .pykov import Chain
except ImportError as e:
    try:
        from pykov import Chain
    except ImportError:
        print("Warning: 'pykov' module seems to not be available. But it is shipped with SMPyBandits. Weird.")
        print("Dou you want to try to install it from https://github.com/riccardoscalco/Pykov ?")
        print("Warning: the 'MarkovianMAB' class will not work...")

# Local imports
try:
    from .plotsettings import signature, wraptext, wraplatex, palette, makemarkers, legend, show_and_save
except ImportError:
    from plotsettings import signature, wraptext, wraplatex, palette, makemarkers, legend, show_and_save

class HMABenv(object):

    def __init__(self, envConfig):
        """

        :param envConfig: <dict> contains parameters to set up the MAB environment
                "isHMAB": <bool> whether or not the environment is for the HMAB setting
                "bandConfig": <dict> contains parameters (both statistical ("bandParams") and non-statistical (e.g. nbBins) to set up each Band object in the environment
                "compareMab" <bool> whether or not to create an equivalent MAB environment
        """
        print("\n\nCreating a new MAB problem ...")  # DEBUG

        self.isChangingAtEachRepetition = False  #: Flag to know if the problem is changing at each repetition or not.
        self.isDynamic = False  #: Flag to know if the problem is static or not.
        self.isMarkovian = False  #: Flag to know if the problem is Markovian or not.
        self.arms = []  #: List of arms
        self._sparsity = None
        self.isHMAB = True


        self.bandConfig = envConfig["bandConfig"]
        self.binConfig = envConfig["binConfig"]


        if isinstance(envConfig, dict):
            print("  Reading arms of this MAB problem from a dictionnary 'envConfig' = {} ...".format(
                envConfig))  # DEBUG

            self.nbBands = envConfig["nbBands"]     # Number of Bands
            self.nbBins = envConfig["nbBins"]     # Number of bins per Band
            self.nbArms = self.nbBands*self.nbBins     # Total number of arms between all Bands
            self.Bands = list()                 # List of Band objects
            for n in range(self.nbBands):
                self.Bands.append(self.Band(self.bandConfig,n)) # Creates a new Band instance and stores it in Z (list)
                self.arms.extend(self.Bands[-1].arms) # Copies the arms from the newly created Band instance for the Environment level
        self.means=np.array([arm.mean for arm in self.arms]) # mean of all arms (i.e. lam_ij forall ij)
        self.bestArms = np.argsort(-self.means)
        self.meansSorted = self.means[self.bestArms]
        self.BBsorted = np.array([self.getBB(x) for x in self.bestArms]).transpose()
        self.maxArm = self.meansSorted[0]  #: Max mean of arms
        self.minArm = self.meansSorted[-1]  #: Min mean of arms
        self.sparsity()
        self.armsSort = None


        if envConfig["verbose"]:
            print("*"*20)
            print("STATS FOR EACH BAND")
            for B in range(self.nbBands):
                Band = self.Bands[B]
                print(f"BAND {B}/{self.nbBands-1}")
                print(f"({B})|Distribution = {Band.bandDistribution} with parameters (loc = {Band.dist_gen.mu},scale = {Band.dist_gen.sigma})")
                print(f"({B})|Number of Arms (Bins) = {Band.nbBins}")
                print(f"({B})|Arm Distributions = [{Band.arms}]")
                print(f"({B})|Best Arm = [{Band.bestArm}] with expected reward  = {Band.binMeans[Band.bestArm]:0.4f}")


        if envConfig["verbose"]:
            print("*" * 20)
            print("OVERALL STATS")
            print(f"Total # of total 'Arms' (Bins) = {self.nbArms}")
            print(f"Best (Band,Bin) [Arm] = {self.BBsorted[:,0]} [{self.bestArms[0]}]  w/ expected reward = {self.maxArm}")
            print("*" * 20)
            print("DONE INITIALIZING THE ENVIRONMENT")
            print("*" * 20)
            print()



    def printTopKBins(self,k):
        Mu = np.zeros(k)
        for i in range(k):
            print(f"(Band, Bin) = ({self.BBsorted[0,i]}, {self.BBsorted[1,i]}) ~ {self.arms[self.bestArms[i]].__repr__()}")
            Mu[i] = self.arms[self.bestArms[i]].mean
        return Mu

    def printBins(self, Arms):
        Mu = []
        for Arm in Arms:
            print(f"(Band, Bin) = ({self.getBB(Arm)}) ~ {self.arms[Arm].__repr__()}")
            Mu.append(self.arms[Arm].mean)
        return np.array(Mu)

    def printBestFits(self, percentile = False):
        if percentile:
            p_vec = []
            for Band in self.Bands:
                print(f"{Band.__bfstr__()} - {self.bandConfig['percentile']} Percentile = {round(Band.bf_percentile,2)}")
                p_vec.append(round(Band.bf_percentile,2))
            return np.array(p_vec)

        else:
            for Band in self.Bands:
                print(Band.__bfstr__())

    def computePercentile(self, Band,Arm):
        # Arm is non BB
        # Band is because the percentile should be computed with regards to a specified Band Distribution
        value = self.arms[Arm].mean  # actual expected value of the arm
        return self.Bands[Band].rv_bf.cdf(value) # The percentile of which the value represents
    class Band:
        #The Band should just be another MAB object (Maybe)
        
        def __init__(self, bandConfig, n):
            bandParams = bandConfig["bandParams"]
            binConfig = bandConfig["binConfig"]
            self.index = n   # Band index
            self.nbBins = bandConfig["nbBins"]
            self.bandDistribution = bandConfig["bandDistribution"]
            self.percentile = bandConfig["percentile"]# Distribution of Z_i i.e. mean reward distribution
            if binConfig["binDistribution"] is UnboundedGaussian:
                self.binDistribution = UnboundedGaussian
            self.empDistribution = {}
            if self.bandDistribution is Normal: ## CHANGE ALL BANDPARAMS TO BE DICT BASED
                self.dist_gen = Normal(bandParams["mu"][n], bandParams["std"][n])
                self.rv_gen = norm(loc = self.dist_gen.mu, scale = self.dist_gen.sigma) # Distribution of the Band (scipy rv object)
                self.arms = list()
                self.binMeans = self.rv_gen.rvs(self.nbBins) #
                self.binStds = binConfig["binParams"] # set bin standard deviation
                for mu_ij in self.binMeans:
                    self.arms.append(self.binDistribution(mu_ij, self.binStds))  #Appending arm e.g. Gaussian(lam_ij, sigma_ij)
                self.dist_bf = Normal(np.mean(self.binMeans), np.std(self.binMeans))
                self.rv_bf = norm(loc = self.dist_bf.mu, scale =self.dist_bf.sigma)
                self.bf_percentile = self.rv_bf.ppf(self.percentile)

            elif self.bandDistribution == "Uniform":
                self.min= bandParams["min"][n]  #Band lower bound (i.e. lower bound of expected bin rewards within the band)
                self.loc = self.min
                self.scale = bandParams["scale"][n] #Scale parameter for the band i.e. width of distribution
                self.max = self.min + self.scale
                self.Z_i = uniform(loc = self.min, scale = self.scale) #Distribution of Band
                self.arms = list()
                self.lam = self.Z_i.rvs(self.nbBins) # Sample of means
                for l in self.lam: # Now we need to create the bin distributions
                    if issubclass(self.binDistribution, UniformArm):
                        mini = l - binConfig["scale"]/2
                        maxi = l + binConfig["scale"]/2
                        self.arms.append(self.binDistribution(mini, maxi))



            # Now we need to create M arms with arm_type Gaussian and means sampled from Z_i
            self.bestArm = np.argmax(self.binMeans)  # Arm with the highest expected reward within the Band

        def sample_bin(self, method = "uniform"):
            if method == 'uniform':
                bin_index = randint(0,self.nbBins)
                reward = arms
            else:
                pass
            return reward, bin_index

        def printBandDist(self):
            self.bandDistribution
        def __str__(self):
            return f"Band [{self.index}]- GD ~  {self.dist_gen.__str__()}"

        def __bfstr__(self):
            return f"Band [{self.index}] - BF ~  {self.dist_bf.__str__()}"


        def plotGenDist(self, ax):
            a = .005
            points = 1000
            x = np.linspace(self.rv_gen.ppf(a), self.rv_gen.ppf(1-a),points)
            label = self.__str__()
            ax.plot(x, self.rv_gen.pdf(x), color = ax.envOpt["color"], label = label)
            return ax

        def plotBfDist(self, ax):
            a = .005
            points = 1000
            x = np.linspace(self.rv_gen.ppf(a), self.rv_gen.ppf(1 - a), points)
            label = self.__bfstr__()
            ax.plot(x, self.rv_gen.pdf(x), color = ax.envOpt["color"], label=label, ls = '-')
            return ax

        def plotBinDist(self, ax):
            stemHeight = 0.1
            ax.stem(self.binMeans, np.ones(self.binMeans.shape[0])*stemHeight, linefmt = ax.envOpt["color"], markerfmt = ax.envOpt["color"]+'o')
            return ax



    def plotDists(self, ax):
        for B in self.Bands:
            ax.envOpt["color"] = 'C'+ str(ax.envOpt["Index"])
            if ax.envOpt["Gen"]:B.plotGenDist(ax)
            if ax.envOpt["BF"]: B.plotBfDist(ax)
            if ax.envOpt["Bin"]: B.plotBinDist(ax)
            ax.envOpt["Index"] = ax.envOpt.get('Index', 0) + 1
        return ax

    def draw(self, choice, t=1, k = 1):
        """ Return a random sample from the armId-th arm, at time t. Usually t is not used."""
        if isinstance(choice, np.int64) or isinstance(choice, int):
            choice = self.getBB(choice)
        Band = choice[0]
        Bin = choice[1]
        if k > 1:
            reward = self.Bands[Band].arms[Bin].draw_nparray((int(k),))
        else:
            reward = self.Bands[Band].arms[Bin].draw(t)
        #print(f"Drawing from (Band, Bin): {choice} which has a rewards ~ N({self.Z[Band].arms[Bin].mean:0.3f},{self.Z[Band].arms[Bin].sigma**2})")
        #print(f"Reward drawn: {reward}")
        return reward

    def get_maxArm(self, horizon=None):
        """Return the vector of max mean of the arms.

        - It is a vector of length horizon.
        """
        return np.full(horizon, self.maxArm)
            

    def sparsity(self):
        """ Estimate the sparsity of the problem, i.e., the number of arms with positive means."""
        if self._sparsity is not None:
            return self._sparsity
        else:
            return np.count_nonzero(self.means > 0)

    def str_sparsity(self):
        """ Empty string if ``sparsity = nbArms``, or a small string ', $s={}$' if the sparsity is strictly less than the number of arm."""
        s, K = self.sparsity(), self.nbArms
        assert 0 <= s <= K, "Error: sparsity s = {} has to be 0 <= s <= K = {}...".format(s, K)
        # WARNING
        # disable this feature when not working on sparse simulations
        # return ""
        # or bring back this feature when working on sparse simulations
        return "" if s == K else ", $s={}$".format(s)

    def lowerbound(self):
        r""" Compute the constant :math:`C(\mu)`, for the [Lai & Robbins] lower-bound for this MAB problem (complexity), using functions from ``kullback.py`` or ``kullback.so`` (see :mod:`Arms.kullback`). """
        return sum(a.oneLR(self.maxArm, a.mean) for a in self.arms if a.mean != self.maxArm)
            
    def reprarms(self, nbPlayers=None, openTag='', endTag='^*', latex=True):
        """ Return a str representation of the list of the arms (like `repr(self.arms)` but better)

        - If nbPlayers > 0, it surrounds the representation of the best arms by openTag, endTag (for plot titles, in a multi-player setting).

        - Example: openTag = '', endTag = '^*' for LaTeX tags to put a star exponent.
        - Example: openTag = '<red>', endTag = '</red>' for HTML-like tags.
        - Example: openTag = r'\textcolor{red}{', endTag = '}' for LaTeX tags.
        """
        if nbPlayers is None:
            text = repr(self.arms)
        else:
            assert nbPlayers >= 0, "Error, the 'nbPlayers' argument for reprarms method of a MAB object has to be a non-negative integer."  # DEBUG
            append_to_repr = ""

            means = self.means
            bestmean = np.max(means)
            bestArms = np.argsort(means)[-min(nbPlayers, self.nbArms):]
            repr_arms = [repr(arm) for arm in self.arms]

            # WARNING improve display for Gaussian arms that all have same variance
            if all("Gaussian" in str(type(arm)) for arm in self.arms) and len({arm.sigma for arm in self.arms}) == 1:
                sigma = self.arms[0].sigma
                repr_arms = [s.replace(', {:.3g}'.format(sigma), '') for s in repr_arms]
                append_to_repr = r", \sigma^2={:.3g}".format(sigma) if latex else ", sigma2={:.3g}".format(sigma)

            if nbPlayers == 0: bestArms = []
            text = '[{}]'.format(', '.join(
                openTag + repr_arms[armId] + endTag
                if (nbPlayers > 0 and (armId in bestArms or np.isclose(arm.mean, bestmean)))
                else repr_arms[armId]
                for armId, arm in enumerate(self.arms))
            )
            text += append_to_repr
        return wraplatex('$' + text + '$') if latex else wraptext(text)

    def createMAB(self):
        envConfig = self.arms
        return MAB(envConfig)

    def getArm(self, Band, Bin):
        return np.ravel_multi_index((Band, Bin), (self.nbBands, self.nbBins))

    def getBB(self, arm):
        return np.unravel_index(arm, (self.nbBands, self.nbBins))

    def plotBandDist(self, ax):
        pass

