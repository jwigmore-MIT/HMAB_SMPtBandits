"""
Based class for al Hierarchical MAB (HMAB) policies
"""
from Policies.Posterior import NormalGamma
from Policies.Posterior import Uniform
from numpy.random import normal as normalvariate
import numpy as np

class HMABBasePolicy(object):
    def __init__(self, nbBands, nbBins, posterior = NormalGamma, priorParams = None):
        """

        :param nbBands:
        :param nbBins:
        :param posterior: <SMPyBandits Posterior>
        :param priorParams: <dict> of initial parameters for our posterior
        """
        self.nbBands = nbBands
        self.nbBins = nbBins
        self.nbArms = nbBins*nbBands  # Arms is the linear version of Band/Bin indexing
        self.posteriorDist = posterior
        self.posteriorBand = [None]*nbBands
        self.likelihoodParams = [None]*nbBands
        self.isHMAB = True


        self.t = -1  #: Internal time

        self.pulls = np.zeros(self.nbArms, dtype= int)      #Count of pulls for each arm
        self.rewards = np.zeros(self.nbArms)    # Sum of rewards accumulated for each arm
        self.lam_est = np.zeros(self.nbArms)    # Estimate of each arm mean

        # For recording actions/rewards in Band/Bin format
        self.pullsBB = np.zeros((nbBands, nbBins), dtype=int)  #: Number of pulls of each band and bin
        self.rewardsBB = np.zeros((nbBands, nbBins))   #: Cumulated rewards of each arms
        self.lam_estBB = np.zeros((nbBands, nbBins))   #: Estimated expected reward for the bin based on observations


        #self.Mu_est = np.zeros(nbBands)
        print(f"Initializing the posteriors for all {self.nbBands} Bands")
        if list(priorParams.values())[0] < 1:       # checks if first value in dictionary is an array of parameters, if not initializes all posteriors the same
            print(f"Assigning all posteriors the parameters:")
            print(priorParams)
            for Band in range(nbBands):
                self.posteriorBand[Band] = posterior(priorParams)
            print(f"Assigning all posterior parameters individually")
            for Band in range(nbBands):
                self.posteriorBand[Band] = posterior(priorParams, i)
        print(f"Computing likelihood (Normal) parameters (mu, tau^-1) for all Bands")
        for Band in range(nbBands):
            self.likelihoodParams[Band] = self.posteriorBand[Band].mean()
            #print(f"""The POSTERIOR for Band ({Band}) is ~ {self.posteriorBand[Band].__str__()}""")
            #print(f"""The LIKELIHOOD for Band ({Band}) is ~ Normal{self.likelihoodParams[Band]}""")
        self.printParams()

    def getArm(self,Band, Bin):
        return np.ravel_multi_index((Band, Bin), (self.nbBands,self.nbBins))

    def getBB(self,arm):
        return np.unravel_index(arm, (self.nbBands,self.nbBins))

    def printParams(self):
        for Band in range(self.nbBands):
            print("*"*20)
            print(f"""The POSTERIOR for Band ({Band}) is ~ {self.posteriorBand[Band].__str__()}""")
            mu = self.likelihoodParams[Band][0]
            prec = self.likelihoodParams[Band][1]
            var = 1/prec
            print(f"""The LIKELIHOOD for Band ({Band}) is ~ Normal(mu = {mu}, var = {var})""")

    def __str__(self):
        """ -> str"""
        return self.__class__.__name__

    def startGame(self):
        """ Start the game (fill pulls and rewards with 0)."""
        self.t = 0
        self.pullsBB.fill(0)
        self.rewardsBB.fill(0)
        self.pulls.fill(0)
        self.rewards.fill(0)

    def getReward(self, Band, Bin, reward):
        """ Give a reward: increase t, pulls, and update cumulated sum of rewards for that arm (normalized in [0, 1])."""
        self.t += 1
        self.pullsBB[Band, Bin] += 1
        self.rewardsBB[Band, Bin] += reward

    def choice(self): #Need this to remain choice for evaluator()
        """ Not defined."""
        raise NotImplementedError(
            "This method choice() has to be implemented in the child class inheriting from BasePolicy.")


    def choiceBand(self):
        """ Not defined."""
        raise NotImplementedError(
            "This method choice() has to be implemented in the child class inheriting from BasePolicy.")

    def choiceBin(self,Band):
        raise NotImplementedError(
            "This method choice() has to be implemented in the child class inheriting from BasePolicy.")


    def computeArmIndex(self, Band, Bin):  # Compute the arm index (i.e. Upper Conf. Bounds) for ArmBelief(Band,Bin)
        if self.pullsBB[Band, Bin] < 1:
            return float('+inf')
        else:
            #return (self.rewards[Band, Bin] / self.pulls[Band, Bin]) + np.sqrt((2 * log(self.t)) / self.pulls[Band, Bin]) # Considering all pulls
            return (self.rewardsBB[Band, Bin] / self.pullsBB[Band, Bin]) + np.sqrt((2 * np.log(np.sum(self.pullsBB[Band,:]))) / self.pullsBB[Band, Bin])  # Considering only pulls within bin

    def computeBandArmIndex(self,Band):
        indexes = np.zeros(self.nbBins)
        for Bin in range(self.nbBins):
            indexes[Bin] = self.computeArmIndex(Band, Bin)
        self.indexes = indexes

    def updatePulls(self, Band, Bin):
        self.pullsBB[Band, Bin] += 1
        self.pulls[self.getArm(Band, Bin)] +=1

    def updateReward(self, Band, Bin, reward, lam_est = True):
        self.rewardsBB[Band, Bin] += reward
        self.rewards[self.getArm(Band, Bin)] += reward
        if lam_est:
            self.lam_estBB[Band, Bin] = self.rewardsBB[Band, Bin] / self.pullsBB[
                Band, Bin]
            self.lam_est[self.getArm(Band, Bin)] = self.lam_estBB[Band, Bin]



    def pullAllArms(self):
        pass