

from SMPyBandits.Policies.HMABPolicy import HMABPolicy
from numpy.random import choice as npchoice
from numpy.random import randint
import numpy as np
from SMPyBandits.Policies.Posterior.Uniform import Uniform
class BandThenBin1(HMABPolicy):

    def __init__(self,nbBands, nbBins, posterior, priorParams, verbose = True, precountMax = None):
        super().__init__(nbBands, nbBins, posterior, priorParams, verbose)
        self.stage = "Pre"  # What "stage" of the algorithm we are in i.e. choosing best Band or choosing best bin within the best band

        self.bestBand = None
        self.eligible_bands = list(range(nbBands))  # Bands that we can choose from
        self.bandMins = np.full(nbBands, -np.inf)
        self.bandMaxs = np.full(nbBands,np.inf)
        if precountMax is None:
            self.precountMax = nbBins
        self.precount = 0
        self.binTransition = None
        self.bandTransition = None
        self.preBand = 0

    def choice(self):
        def chooseBand():
            if self.stage == "Band":
                # Randomly sample a bin and update its posterior
                #
                Band = npchoice(self.eligible_bands)
            elif self.stage == "Bin":
                #We already know the best band, so select it
                Band = self.bestBand
            return Band

        def chooseBin(Band):
            if self.stage == "Band":
                #Current goal is to estimate the lower band from the bin distribution, so sample uniformly from bins
                Bin = randint(0,high = self.nbBins)
            elif self.stage == "Bin":
                self.computeBandArmIndex(Band)
                best_ind = np.argmax(self.indexes)
                if self.verbose:
                    print("*" * 20)
                    print(f"Choosing a Bin within Band ({Band})")
                    # ind_formatted = (f"{ind:0.3f}" for ind in self.indexes)
                    print(f"The bin indices in order are: {np.array_str(self.indexes, precision=3)}")
                    print(f"""The chosen Bin is ({best_ind}) with index = {self.indexes[best_ind]}""")
                Bin = best_ind
            return Bin
        if self.stage == "Pre":
            if (self.precount + 1)/(self.nbBands/self.nbBands) >= 1:
                self.preBand +=1
            bin_choice = npchoice(range(self.nbBins))# Uniformly sample from either bin or band
            choice = self.getArm(self.preBand, bin_choice)
            self.precount +=1
            if self.precount >= self.precountMax:
                self.stage = "Band"
                self.bandTransition = self.t
        else:
            Band  = chooseBand()
            Bin = chooseBin(Band)
            choice = self.getArm(Band, Bin)
        return choice

    def compareBands(self):
        # Find greatest lower bound
        # Check if any upper bounds are less than the greatest lower bound

        if issubclass(self.posteriorDist, Uniform):
            max_lowerbound = np.max(self.bandMins) #the max estimated lower bound of the support for all band distributions
            e_bands = self.eligible_bands
            for Band in e_bands:
                if self.bandMaxs[Band] < max_lowerbound:
                    self.eligible_bands.remove(Band)
                    if self.verbose:
                        print(f"Band {Band} has max support of {self.bandMaxs}")
                        print(f"which is less than the greatest lower bound of {max_lowerbound}")
                        print(f"Deleting Band {Band} from eligible bands")
                        print(f"Remaining eligible bands: {self.eligible_bands}")
        if self.eligible_bands.__len__() <2:
            self.bestBand = self.eligible_bands[0]
            self.stage = "Bin"
            self.binTransition = self.t
            if self.verbose:
                print(f"Band {self.bestBand} was estimated to be the best band")
                print(f"Switching to the 'Bin' stage")

    def getReward(self, choice, reward):
        (Band, Bin) = self.getBB(choice)
        self.t += 1
        self.updatePulls(Band, Bin)
        self.updateReward(Band, Bin, reward, lam_est=True)  # update reward and estimated expected reward for bin

        self.posteriorBand[Band].update(self.lam_estBB[Band, Bin])# This updates the posterior

        self.likelihoodParams[Band] = self.posteriorBand[Band].likelihoodParams

        self.bandMins[Band] = self.likelihoodParams[Band]["loc"]
        self.bandMaxs[Band] = self.likelihoodParams[Band]["max"]
        if self.verbose:
            print("*"*20)
            print(f"Chosen (Band/Bin):({Band},{Bin})")
            print(f"Received Reward: {reward}")
            print(f"Estimated lambda's: {self.lam_estBB[Band,:]}")
            print(f"Band min: {self.bandMins[Band]}")
            print(f"Band max: {self.bandMaxs[Band]}")
            print(f"New Band Likelihood Params:")
            print(self.likelihoodParams[Band])
            print("*" * 20)
            print()
        if self.stage == "Band":
            self.compareBands()

    def printStageTimeline(self):
        print(f"Policy Stage Timeline:")
        print(f"Pre:  (0,{self.bandTransition})")
        print(f"Band: ({self.bandTransition},{self.binTransition})")
        print(f"Bin: ({self.binTransition}, {self.t})")