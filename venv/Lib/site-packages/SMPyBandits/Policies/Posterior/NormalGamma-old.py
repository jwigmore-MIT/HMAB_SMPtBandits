# Local Imports
from .Posterior import Posterior
from scipy.stats import norm
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color='bgrcmyk')

from numpy.random import gamma, normal



class NormalGamma(Posterior):

    def __init__(self, paramDict, i = 0):
        r"""Create a posterior assuming the prior is : N(eta, tau_i^(-1))..
        """
        if isinstance(paramDict["eta"], list):
            eta = paramDict["eta"][i]
            gam = paramDict["gam"][i]
            alpha = paramDict["alpha"][i]
            beta = paramDict["beta"][i]
        else:
            eta = paramDict["eta"]
            gam = paramDict["gam"]
            alpha = paramDict["alpha"]
            beta = paramDict["beta"]


        # Normal Parameters
        self._eta = float(eta)  # initial value
        self.eta = float(eta)  #: Parameter :math:`\eta` of the posterior
        self._gam = gam  # initial value
        self.gam = gam  #: The parameter :math:`\sigma` of the posterior

        # Gamma Parameters
        self._alpha = alpha
        self.alpha = alpha
        self._beta = beta
        self.beta = beta

        # internal memories
        self._nb_data = 0  # number of samples!
        self._sum_data = 0.0  # sum of samples!

        self.likelihoodParams = {
            "loc": np.nan,
            "scale": np.nan,
            "_loc": np.nan,
            "_scale": np.nan,
        }
        self.setLLParams()
        self.setInitLLParams()
        self.LLRV = None

    def printPosterior(self):
        return "NormalGamma(eta = {:.3g},gam = {:.3g}, alpha =  {:.3g}, beta = {:.3g})".format(self.eta, self.gam, self.alpha, self.beta)

    def printInitPrior(self):
        return "NormalGamma(eta = {:.3g},gam = {:.3g}, alpha =  {:.3g}, beta = {:.3g})".format(self._eta, self._gam, self._alpha, self._beta)

    # Need to change this for seperate likelihood implementation
    def printLikelihood(self):
        return "Normal(mu = {:.3g}, sigma = {:.3g})".format(self.likelihoodParams["loc"], self.likelihoodParams["scale"])

    def printInitLikelihood(self):
        return "Normal(mu = {:.3g}, sigma = {:.3g})".format(self.likelihoodParams["_loc"], self.likelihoodParams["_scale"])

    def printAllParams(self):
        print(f"Initial Prior Parameters: {self.printInitPrior()})")
        print(f"Initial Likelihood Parameters: {self.printInitLikelihood()})")
        print(f"Current Posterior Parameters: {self.printPosterior()})")
        print(f"Current Likelihood Parameteres: {self.printLikelihood()})")




    def reset(self, eta=None, tau = None):
        r""" Reset the for parameters :eta and tau_i, as when creating a new NormalGamma posterior."""
        if eta is None:
            self.eta = self._eta
        if tau is none:
            self.tau = tau

    def sample(self):
        # https://en.wikipedia.org/wiki/Normal-gamma_distribution
        # Random variable X|T ~ N(eta, 1/(gam*T) where T|(alpha, beta) ~ Gamma(alpha, beta)
        # Then the joint distribtuion (X,T) ~ NormalGamma(eta, gam, alpha, beta)
        # Sample first from gamma(alpha, beta) to get T
        # Sample from normal(eta, 1/(lgam*T)) to get X
        T = gamma(self.alpha, 1./self.beta)
        var = (1/(T*self.gam))
        X = normal(loc = self.eta, scale = np.sqrt(var))
        return (X,T)

    def sample_k(self, k=100):
        X = np.zeros((k,1))
        T = np.zeros((k,1))
        for ii in range(k):
            X[ii],T[ii] = self.sample()
        return X,T

    def setLLParams(self):
        self.likelihoodParams["loc"] = self.eta
        self.likelihoodParams["scale"] = np.sqrt(1/(self.alpha/self.beta))

    def setInitLLParams(self):
        self.likelihoodParams["_loc"] = self.likelihoodParams["loc"]
        self.likelihoodParams["_scale"] = self.likelihoodParams["scale"]

    def varianceParams(self): # Variance of the X and T values for the Normal Gamma Distribution
        if self.alpha == 1: # When alpha
            return np.inf
        else:
            return (self.beta/(self.gam*(self.alpha-1)), self.alpha/self.beta**2)
    
    def update(self, obs): # This observation is an updated lambda estimate not reward
        self._nb_data +=1
        self._sum_data += float(obs)
        eta_new = (self.gam*self.eta+obs)/(self.gam + 1)
        gam_new = self.gam + 1
        alpha_new = self.alpha + 1/2
        beta_new = self.beta + 1/2*(self.gam*(obs - self.eta)**2/(self.gam+1))
        self.eta = eta_new
        self.gam = gam_new
        self.alpha = alpha_new
        self.beta = beta_new

        self.setLLParams()

    def update2(self, obs): # This observation is a vector of all estimated expected bin rewards
        # Normal Gamma updates are now based on n-samples instead of 1
        self._nb_data +=1
        #self._sum_data += float(obs)
        x = np.mean(obs)
        s = np.var(obs)
        n = obs.shape[0]

        eta_new = (self.gam*self.eta+n*x)/(self.gam + n)
        gam_new = self.gam + n
        alpha_new = self.alpha + n/2
        beta_new = self.beta + 1/2*(n*s+self.gam*n*(x - self.eta)**2/(self.gam+n))
        self.eta = eta_new
        self.gam = gam_new
        self.alpha = alpha_new
        self.beta = beta_new
        self.setLLParams()

    def update3(self, obs): # This observation is a vector of all estimated expected bin rewards
        # Normal Gamma updates are now based on n-samples instead of 1
        self._nb_data +=1
        #self._sum_data += float(obs)
        x = np.mean(obs)
        s = np.var(obs)
        n = obs.shape[0]

        eta_new = (self._gam*self._eta+n*x)/(self._gam + n)
        gam_new = self._gam + n
        alpha_new = self._alpha + n/2
        beta_new = self._beta + 1/2*(n*s+self._gam*n*(x - self._eta)**2/(self._gam+n))
        self.eta = eta_new
        self.gam = gam_new
        self.alpha = alpha_new
        self.beta = beta_new
        self.setLLParams()

    def getInitParams(self):
        return self._eta, self._gam, self._alpha, self._beta


    def plot_likelihood(self, fig, axes):



        fig, ax = plt.subplots(2, 1, sharey=True, sharex=True)
        # plt.rcParams.update({"text.usetex": True,})
        colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']
        markers = makemarkers(self.nbPolicies)



        if issubclass(policy.posteriorDist, Uniform):
            for Band in env.X:
                # Get true distribution
                c = colors[Band.i]
                i = Band.i
                X_i = Band.X_i  # Frozen r.v. representing the distribution of E[lam_ij]
                ub = X_i.ppf(1)+.01 # Upper Bound for linspace
                lb = X_i.ppf(0)-.01 # Lower Bound for linspace

                n = np.linspace(lb, ub, 500)
                y = X_i.pdf(n)
                ax[0].plot(n, y, '-', color=c,
                           label=f'Band ({Band.i}) ~ {X_i.dist.name}(loc={X_i.kwds["loc"]}, scale = {X_i.kwds["scale"]})')
                arms = Band.lam
                y_arms = np.ones(len(arms))*np.max(y)
                #ax[0].hist(arms, bins = env.nbArms*50, color=c, density=False, histtype='bar', label=f"Empirical ArmBelief Distribution", alpha=1)
                binWidth = self.cfg['environment'][envId]["envConfig"]["bandConfig"]["binConfig"]["scale"] # Need to implement this better lol
                ax[0].bar(arms, y_arms, width = binWidth, edgecolor = c, label=f"Empirical ArmBelief Distribution", fill = True, alpha = 0.2 )

                ax[0].legend(loc='best', frameon=False)

                X_init = uniform(loc = policy.posteriorBand[i]._min, scale = policy.posteriorBand[i]._scale)
                ub1 = X_init.ppf(1) + .01  # Upper Bound for linspace
                lb1 = X_init.ppf(0) - .01  # Lower Bound for linspace
                n1 = np.linspace(lb1, ub1, 500)
                c2 = colors[Band.i * 2]
                if i == 0:
                    ax[1].plot(n1, X_init.pdf(n1), '--', color = 'black',
                           label=f'Prior Estimate ~ {X_init.dist.name}(loc={X_init.kwds["loc"]}, scale = {X_init.kwds["scale"]})')


                X_est = uniform(loc = policy.likelihoodParams[i]["loc"], scale = policy.likelihoodParams[i]["scale"])
                ub2 = X_est.ppf(1) + .01  # Upper Bound for linspace
                lb2 = X_est.ppf(0) - .01  # Lower Bound for linspace
                n2 = np.linspace(lb2, ub2, 500)
                ax[1].plot(n2, X_est.pdf(n2), '-', color=c2,
                           label=f'Band ({Band.i}) ~ {X_est.dist.name}(loc={X_est.kwds["loc"]:.3f}, scale = {X_est.kwds["scale"]:.3f})')

        ax[0].legend(loc='best', frameon=False)
        ax[1].legend(loc='best', frameon=False)
        fig.suptitle(f"Bands: {env.nbBands}, Bins: {env.nbBins}")
        fig.show()

    def getLLpercentile(self,p):
        return norm(loc = self.likelihoodParams["loc"], scale = self.likelihoodParams["scale"]).ppf(p)

    
    def getLLpercentile2(self,):
        return self.likelihoodParams["loc"] + 3*self.likelihoodParams["scale"]

