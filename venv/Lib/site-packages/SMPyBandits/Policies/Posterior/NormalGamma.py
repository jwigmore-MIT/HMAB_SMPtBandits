# Local Imports
from .Posterior import Posterior
from scipy.stats import norm
import numpy as np

from numpy.random import gamma, normal



class NormalGamma(Posterior):

    def __init__(self, param_tup):
        r"""Create a posterior assuming the prior is : N(eta, tau^(-1))..
        """
        eta = param_tup[0]
        gam = param_tup[1]
        alpha = param_tup[2]
        beta = param_tup[3]

        # Normal Parameters
        self._eta = float(eta)  # initial value
        self.eta = float(eta)  #: Parameter :math:`\eta` of the posterior
        self._gam = gam  # initial value
        self.gam = gam  #: The parameter :math:`\sigma` of the posterior

        # Gamma Parameters
        self._alpha = alpha
        self.alpha = alpha
        self._beta = beta
        self.beta = beta

        # internal memories
        self._nb_data = 0  # number of samples!
        self._sum_data = 0.0  # sum of samples!

    def __str__(self):
        return "NormalGamma(eta = {:.3g},gam = {:.3g}, alpha =  {:.3g}, beta = {:.3g})".format(self.eta, self.gam, self.alpha, self.beta)


    def reset(self, eta=None, tau = None):
        r""" Reset the for parameters :eta and tau, as when creating a new NormalGamma posterior."""
        if eta is None:
            self.eta = self._eta
        if tau is none:
            self.tau = tau

    def sample(self):
        # https://en.wikipedia.org/wiki/Normal-gamma_distribution
        # Random variable X|T ~ N(eta, 1/(gam*T) where T|(alpha, beta) ~ Gamma(alpha, beta)
        # Then the joint distribtuion (X,T) ~ NormalGamma(eta, gam, alpha, beta)
        # Sample first from gamma(alpha, beta) to get T
        # Sample from normal(eta, 1/(lgam*T)) to get X
        T = gamma(self.alpha, 1./self.beta)
        var = (1/(T*self.gam))
        X = normal(loc = self.eta, scale = np.sqrt(var))
        return (X,T)

    def sample_k(self, k=100):
        X = np.zeros((k,1))
        T = np.zeros((k,1))
        for ii in range(k):
            X[ii],T[ii] = self.sample()
        return X,T

    def mean(self):
        return (self.eta, self.alpha/self.beta)

    def variance(self):
        return (self.beta/(self.gam*(self.alpha-1)), self.alpha/self.beta**2)
    
    def update(self, obs):
        self._nb_data +=1
        self._sum_data += float(obs)
        eta_new = (self.gam*self.eta+obs)/(self.gam + 1)
        gam_new = self.gam + 1
        alpha_new = self.alpha + 1/2
        beta_new = self.beta + 1/2*(self.gam*(obs - self.eta)**2/(self.gam+1))
        self.eta = eta_new
        self.gam = gam_new
        self.alpha = alpha_new
        self.beta = beta_new

    def getInitParams(self):
        return self._eta, self._gam, self._alpha, self._beta

    


