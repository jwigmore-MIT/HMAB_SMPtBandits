from SMPyBandits.Policies.HMABPolicy import HMABPolicy

import numpy as np

class HMABAlgo3(HMABPolicy):

    def __init__(self,nbBands, nbBins, BayesSetup = None, verbose = True, AlgoParams = None):
        super().__init__(nbBands, nbBins, BayesSetup, verbose)
        self.AlgoParams = AlgoParams
        self.initialize_distributions()
        self.percentile = AlgoParams["percentile"]
        self.eps = AlgoParams["eps"] # Will explore with probability eps even if it believes the best bin has been found
        self.CI = True
        self.confidence = AlgoParams["confidence"]



    def initialize_distributions(self):
        if self.verbose:print(f"Initializing the hyperpriors for all {self.nbBands} Bands")
        self.BandDist = self.BayesSetup["BandDist"]
        for B in range(self.nbBands):
            # Using frequentist estimation so priors/posteriors not needed
            # self.posteriors[B] = self.BayesSetup["hyperprior"](self.BayesSetup["hyperparameters"])
            self.Bands[B] = self.Band(self,B,self.nbBins,self.BayesSetup["BandDist"],self.BayesSetup["InitBandParams"])
            for b in range(self.nbBins):
                self.Bands[B].Bins[b] = self.Bin(self.Bands[B], b, self.BayesSetup["BinDist"], self.BayesSetup["InitBinParams"])
                self.Bins[self.getArm(B,b)] = self.Bands[B].Bins[b]
                # self.EstBinDist[self.getArm(B,b)] = self.BayesSetup["BinDist"](self.BayesSetup["InitBinParams"])


        self.Phase = 1
        self.T = self.AlgoParams["T"] # Known time-horizon
        self.m = self.AlgoParams["m"] # Chosen number of bins sampled in phase #1 per band
        self.mIndices = np.random.choice(self.nbBins, self.m, False) # Selection random sample of m bins within range(nbBins) without replacement
        self.P1 = self.AlgoParams["P1"] # Percentage of time spent in phase 1
        self.P2 = 1 - self.P1 # Percentage of time spent in phase 2
        self.Phase = 1
        self.s1 = np.floor(self.P1*self.T/(self.nbBands*self.m)) # Phase one samples per bin
        if "s2" in self.AlgoParams.keys():
            self.s2 = self.AlgoParams["s2"] # Minimum samples per bin in phase 2
        else:
            self.s2 = self.s1
        self.nbDraws = int(self.s1)

        # Not ideal implementation, but used to loop through the bands/bins in phase 1
        self.P1BandCounter = 0
        self.P1BinCounter = 0



        return 0
    def printAlgoParams(self):
        print(f"Horizon (T):{self.T}")
        print(f"P1 Bins/Band (m): {self.m}")
        print(f"P1: {self.P1}")
        print(f"P2: {self.P2}")
        print(f"Actual Phase Split: {self.PhaseTransition}/{self.T}")
        print(f"percentile: {self.percentile}")
        print(f"mIndices: {self.mIndices}")

    def choice(self):
        # Start by updating the last bins distribution because we got the reward from the environment

        if self.Phase ==1: ## We are in phase1

            choice = self.getArm(self.P1BandCounter, self.mIndices[self.P1BinCounter])
            self.P1BinCounter += 1
            if self.P1BinCounter >= self.m:
                self.P1BandCounter += 1
                self.P1BinCounter = 0
                if self.P1BandCounter >= self.nbBands:
                    self.Phase = 2
                    self.PhaseTransition = self.t

        else: ## This is phase 2
            self.nbDraws = int(min(self.T-self.t,self.s2))
            percentiles = [x.percentile for x in self.Bands[:]]
            BandChoice = np.argmax(percentiles)
            p_max = percentiles[BandChoice]
            Band = self.Bands[BandChoice]
            validBins = Band.BinSampled # list of bins that have been sampled i.e. have a valid estimation
            mus = [Band.estBinMeans[x] for x in validBins]
            bestMus = np.argmax(mus)
            bestBin = validBins[bestMus]
            muMax = mus[bestMus]
            r = np.random.random()
            if muMax >= p_max and self.eps < r:
                BinChoice = bestBin
            elif Band.BinSampled.__len__() >= self.nbBins and self.eps < r:
                BinChoice = bestBin
            else:
                BinChoice = np.random.choice([x.bindex for x in Band.Bins[:] if not x.sampled]) # choose a random bin that hasn't been sampled yet
            choice = self.getArm(BandChoice,BinChoice)
        return choice

    # def updateDists(self):
    #     if self.t < self.T*self.P1: ## We are in phase1, update bins only
    #         if self.P1BinCounter ==0 and self.P1BandCounter > 0: # switched to new band, estimate old band distribution
    #             self.updateBin(self.P1BandCounter - 1, self.mIndices[m]) #Update the last bin in m of the last band
    #             self.updateBand(self.P1BandCounter - 1) # Update the last band
    #         else:
    #             self.updateBin(self.P1BandCounter, self.P1BinCounter-1) #update last bin
    #
    # def updateBin(self, Band, Bin):
    #     arm = self.getArm(Band,Bin)
    #     # rewards = self.rewards[]














